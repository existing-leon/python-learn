""""""

"""
返回数组中数量超过半数的元素，要求时间复杂度O(n)、空间复杂度O(1)。
示例：
	输入：nums = [2,2,1,1,1,2,2]
	输出：2
"""

"""
1）思路分析
为了严格符合复杂度要求，可以使用多数投票算法，多数投票算法也叫摩尔投票算法。摩尔投票算法的核心思想是对立性和抵消，它基于这样一个事实：如果一个元素在数组中出现的次数超过数组长度的一半，那么在不断消除不同元素对的过程中，这个多数元素最终会留下来。
具体来说，算法维护两个变量：一个是候选元素 candidate，另一个是该候选元素的计数 count。在遍历数组的过程中，遇到与候选元素相同的元素时，计数加 1；遇到不同的元素时，计数减 1。当计数减为 0 时，说明当前候选元素被抵消完，需要更换候选元素为当前遍历到的元素，并将计数重置为 1。
算法步骤
	初始化：
	选择数组的第一个元素作为初始候选元素 candidate。
	将计数 count 初始化为 1。
	遍历数组：
	从数组的第二个元素开始遍历。
	若当前元素与候选元素相同，count 加 1。
	若当前元素与候选元素不同，count 减 1。
	当 count 变为 0 时，将当前元素设为新的候选元素，并将 count 重置为 1。
	返回结果：
	遍历结束后，candidate 即为多数元素。

"""


def majorityElement(nums):
    # 初始化候选元素为数组的第一个元素
    candidate = nums[0]
    # 初始化候选元素的票数为1
    count = 1
    # 从数组的第二个元素开始遍历
    for num in nums[1:]:
        if num == candidate:
            # 如果当前元素与候选元素相同, 票数 + 1
            count += 1
        else:
            # 如果当前元素与候选元素不同, 票数 - 1
            count -= 1
            if count == 0:
                # 当票数为 0 时, 更新候选元素为当前元素, 并将票数重置为 1
                candidate = num
                count = 1
    return candidate


if __name__ == '__main__':
    # 首先数组需要满足有其一元素的个数超过数据长度的一半才行
    nums = [2, 2, 1, 1, 1, 2, 2]
    print(majorityElement(nums))
