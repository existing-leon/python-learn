"""
理论知识
"""

"""
数据结构是为了高效访问数据而设计出的一种数据的组织和存储方式。
具体来说：一个数据结构包含了一个数据元素的集合、数据元素之间的关系以及访问和操作数据的方法。
"""

"""
数据的逻辑结构反映了数据元素之间的逻辑关系。逻辑结构可分为线性和非线性。
线性：数组、链表、栈、队列
非线性：树、图
"""
"""
数据的物理结构反映了数据在计算机内存中的存储结构。
连续存储：借助数据之间的相对位置来表示数据元素之间的逻辑关系；如：数组
分散存储：借助知识数据位置的指针来表示数据元素之间的逻辑关系；如：链表
"""

"""
算法：一个用于解决特定问题的有限指令序列（计算机可以执行的操作）
五大特性：
    输入：算法具有0个或多个输入
    输出：算法至少有1个输出
    有穷性：算法在有限的步骤之后会自动结束而不会无限循环, 并且每一个步骤可以在可接受的时间内完成
    确定性：算法中的每一步都有确定的含义, 不会出现二义性
    可行性：算法的每一步都是清楚且可行的, 能让用户用纸笔计算而求出答案
"""

"""
# 时间复杂度为 5n + 5, 其中 n 是数组的长度
def sum(nums):
    sum_num = 0  # 1次赋值
    i = -1  # 1次赋值
    while (i := i + 1) < len(nums):  # n+1次加法运算 n+1次赋值运算 n+1次比较运算
        sum_num += nums[i]  # n次加法运算 n次赋值于是暖
    return sum_num


# 按照最大来看, 是5n
def find_max(nums):
    max_num = nums[0]   # 1次赋值
    i = 0   # 1次赋值
    while (i := i + 1) < len(nums): # n次加法运算, n次赋值, n次比较
        if nums[i] > max_num:   # n - 1 次比较运算
            max_num = nums[i]   # 0 ~ (n-1)次赋值
    return max_num
    
# 总结：
# 时间复杂度统计的是算法运行时执行的基本指令数, 而非绝对运行时间
# 时间复杂度体现的是算法基本指令数随输入规模 n 增大时的变化趋势
"""

"""
# 二分查找法, 时间复杂度为 log n
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
"""

"""
# 求数组中所有元素的和, 时间复杂度为 n
def sum(nums):
    sum_num = 0
    for num in nums:
        sum_num += num
    return sum_num
"""

"""
# 归并排序：分而治之, 时间复杂度 n * log n
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2

    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])

    return result
"""

"""
# 冒泡排序, 时间复杂度为 n 的平方
def bubble_sort(nums):
    for i in range(len(nums) - 1):
        for j in range(len(nums) - 1 - i):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
"""

"""
# 全排列, 时间复杂度为 n!
def permute(nums):
    result = []
    if len(nums) == 1:
        return [nums]

    for i in range(len(nums)):
        remaining = nums[:i] + nums[i + 1:]
        for perm in permute(remaining):
            result.append([nums[i]] + perm)
    return result
"""

#########################################################################
"""
抽象数据类型与数据结构的关系：
    抽象数据类型：强调的是数据的逻辑特性和操作的功能, 是一种抽象的概念, 不涉及具体的实现细节。
            它是从用户的角度来描述数据和操作的。
    数据结构：是抽象数据类型的具体实现, 它关注的是数据在计算机内存中的存储方式和操作的具体实现算法。
            例如：栈这种抽象数据类型可以用数组或链表等数据结构来实现。
"""

"""
链表（Linked List）是一个线性结构, 由一系列节点（Node）组成, 每个节点包含一个数据元素和一个指向下一节点的指针（Pointer）。
通常我们将链表中的第一个节点称为头结点, 并将头结点的位置作为整个链表的位置标识。

常见链表分类：
    单向链表：单向链表的节点包含值和指向下一节点的引用。我们将首个节点称为头节点, 将最后一个节点称为尾节点, 尾节点指向空 None。
    环形链表：将单向链表的尾节点指向头节点（首尾相接）, 则得到一个环形链表, 在环形链表中, 任意节点都可以视作头节点。
    双向链表：双向链表记录了两个方向的引用, 同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用。
"""

"""
栈（Stack）是一个线性结构, 其维护了一个有序的数据列表, 列表的一端称为栈顶（top）, 另一端称为栈底（bottom）。
栈对数据的操作有明确限定, 插入元素只能由栈顶进行, 删除元素也只能栈顶开始逐个进行, 通常将插入元素称为入栈（push），删除元素称为出栈（pop）。
栈保证了后进先出的原则（LIFO, Last-In-First-Out）
栈的底层实现既可以选择数组也可以选择链表, 只要能保证后进先出的原则即可。
"""

"""
（1）题目描述
给定一个只包括“(”，“)”，“[”，“]”，“{”，“}”的字符串s，判断字符串是否有效。
有效字符串需满足：
	左括号必须用相同类型的右括号闭合。
	左括号必须以正确的顺序闭合。
	每个右括号都有一个对应的相同类型的左括号。
分析：
遇到左括号则入栈，遇到右括号则出栈一个左括号与之匹配，如果能够匹配则继续，如果匹配失败或者栈为空则返回False。
"""

"""
class Solution:
    def isValid(self, s):
        stack = []
        for i in s:
            match i:
                case '(' | '[' | '{':
                    stack.append(i)
                case ')':
                    if (not stack) or (stack.pop() != '('):
                        return False
                case ']':
                    if (not stack) or (stack.pop() != '['):
                        return False
                case '}':
                    if (not stack) or (stack.pop() != '{'):
                        return False

        return True if not stack else False


if __name__ == "__main__":
    solution = Solution()
    s = "()[]{}"
    print(s, solution.isValid(s))
    s = "(]"
    print(s, solution.isValid(s))
    s = "([)]"
    print(s, solution.isValid(s))
    s = "{[]}"
    print(s, solution.isValid(s))
"""

"""
队列（Queue）也是一个线性结构, 其同样维护了一个有序的数据列表, 队列的一段称为队首, 另一端称为队尾。
队列对数据操作做出了明确限定, 插入元素只能从队尾进行, 删除元素只能从队首进行, 通常将插入操作称为入队（enqueue）, 将删除操作称为出队（dequeue）。
队列保证了先进先出（FIFO, First-In-First-Out）的原则。

队列的底层实现既可以选择数组也可以选择链表, 只要能保证先进先出的原则即可。
常见队列：
    单向队列：只能从一端插入数据, 从另一端删除数据, 遵循先进先出。
    双向队列：在队列的两端都可以进行插入和删除操作。
"""

"""
哈希表（Hash Table, 也叫散列表）, 由一系列键值对（key-value pairs）组成, 并且可以通过键（key）查找对应的值（value）。
哈希表常见的一个操作是根据key来查找value, 考虑到数组查询效率最高, 选择基于数组实现哈希表。

哈希表的核心组件是哈希函数. 该函数将key转换为一个数组索引. 哈希函数的目标是尽量均匀地将所有可能的key分布到表的不同位置, 以减少冲突的发生。
哈希函数的执行步骤分为两步：
 >>  通过某种哈希算法计算出key的哈希值
 >>  哈希值对数组长度取余, 获取key对应的数组索引
 index = hash(key) % capacity
 
 哈希函数可能会将不同的键值映射到同一个索引位置, 这就是所谓的哈希冲突。
 处理方式：
    链式法（Chaining）
    开放寻址法（Open Addressing）
    
负载因子（Load Factor）是哈希表中元素个数与表的大小的比率。当负载因子过高时, 可能需要进行扩容操作, 以保持操作的速率。
较小的负载因子可以减少冲突的可能性, 较大的负载因子可以提高哈希表的内存使用率。通常情况下负载因子在 0.7 ~ 0.8
"""

"""
树（Tree）是一系列具有层次关系的节点（Node）组成。

二叉树（Binary Tree）：每个节点最多只能有两个子节点, 两个子节点分别被称为左子节点和右子节点。
以左子节点为根节点的子树被称为左子树, 以右子节点为根节点的子树被称为右子树。

采用数组结构存储的二叉树, 访问与遍历速度较快。但不适合存储数据量过大的树, 且增删效率较低, 而且树中存在大量None的情况下空间利用率较低, 因此不是主流方式。

完全二叉树只有最下面一层的节点未被填满, 且靠左填充。
满二叉树所有层的节点都被完全填满, 满二叉树也是一种完全二叉树。
平衡二叉树中任意节点的左右子树高度之差不超过1。
二叉搜索树中的每个节点的值, 大于其左子树中的所有节点的值, 并且小于右子树中的所有节点的值。
AVL树是一种自平衡的二叉搜索树, 插入和删除时会进行旋转操作来保证树的平衡性。
红黑树是一种特殊的二叉搜索树, 除了二叉搜索树的要求外, 它还具有一下特性：
    >> 每个节点或者是黑色, 或者是红色
    >> 根节点是黑色
    >> 每个叶节点都是黑色. 这里叶节点是指为空（None）的节点。
    >> 红色节点的两个子节点必须是黑色的. 即从每个叶到根的所有路径上不能有两个连续的红色节点。
    >> 从任一个节点到其每个叶的所有路径上包含相同数目的黑色节点。
堆（Heap）是一种满足特定条件的完全二叉树
    >> 大顶堆
    >> 小顶堆
B树是一种自平衡的多路查找树。
B+树是B树的优化版本。
"""

"""
图是比树更普遍的结构, 可以认为树是一种特殊的图, 图由节点和边组成。
    >  节点：也称为顶点, 是图的基础部分.
    >  边：连接两个节点, 也是图的基础部分. 可以是单向的, 也可以是双向的.
    >  权重：边可以添加 "权重" 变量.
    >  邻接：两节点之间存在边, 则称这两个节点邻接.
    >  度：一个节点的边的数量. 入度为指向该节点的边的数量, 出度为该节点指向其他节点的边的数量.
    >  路径：从一节点到另一节点所经过的边的序列.
    >  环：首尾节点相同的路径.

图的分类：
    
    有向图：边是单向的
    无向图：边是双向的
    
    连通图：从某个节点出发, 可以到达其余任意节点
    非连通图：从某个节点出发, 有节点不可达
    
广度优先搜索（BFS, Breadth First Search）：
    从起始节点开始, 首先访问该节点的所有邻接节点, 然后再访问邻接节点的邻接节点, 依此类推, 逐层访问节点.
深度优先搜索（DFS, Depth First Search）:
    尽可能地深入到图的每一个分支, 直到不能再深入为止, 然后回溯到上一个节点, 继续尝试其他的分支.
"""

"""
分治算法的基本思想：
    将原问题递归的分解为若干个（通常是两个以上）规模较小、相互独立且性质相同的子问题, 直到子问题足够简单, 简单到可以直接求解。然后在返回结果, 逐个解决上层问题。
能使用分治算法解决的问题通常需要具备以下特点：
    可分解：问题可以被划分为多个规模较小的子问题。这些子问题通常具有相同的性质, 并且可以独立地解决.
    存在基本情况：问题被分解的小到一定程度后, 就变得非常简单, 简单到可以直接求解.
    可合并：可以通过合并多个子问题的解, 得到原问题的解.
"""

"""
回溯算法是一种通过探索所有可能的解来解决问题的算法。回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用递归方法来实现。
回溯算法的基本步骤可以总结为：
	选择：在每个决策点选择一个候选解。
	探索：递归地继续在下一个决策点上做选择。
	验证：在每次选择之后，检查当前路径是否满足条件。
	回溯：当某条路径不满足条件或无法继续时，回到上一步，尝试其他可能的选择。
"""
