import numpy as np

x = np.array([[1, 2], [3, 4], [5, 6]])
# 获取数组中 (0,0)，(1,1) 和 (2,0) 位置处的元素
y = x[[0, 1, 2], [0, 1, 0],]
print(y)

# 获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]
x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])
print(f'我们的数组是：\n {x} \n')
rows = np.array([[0, 0], [3, 3]])
cols = np.array([[0, 2], [0, 2]])
y = x[rows, cols]
print(f'这个数组的四个角的元素是: \n {y} \n')

# 可以借助切片 : 或 ... 与索引数组组合, 如下
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = a[1:3, 1:3]
c = a[1:3, [1, 2]]
d = a[..., 1:]
print(b)
print(c)
print(d)

# -----------------------------

# 获取大于 5 的元素
x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])
print(f'我们的数组是：\n {x} \n')
print(f'大于 5 的元素：\n {x[x > 5]}')

# 使用 ~ (取补运算符) 来过滤 NaN
a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5])
print(f'非　NaN 的元素：\n {a[~np.isnan(a)]}')

# 从数组中过滤掉非复数元素
a = np.array([1, 2 + 6j, 5, 3.5 + 5j])
print(a[np.iscomplex(a)])

print()
# -----------------------------

# 一维数组只有一个轴 axis = 0, 所以一维数组就在 axis = 0 这个轴上取值
x = np.arange(9)
print(x)
# 一维数组读取指定下标对应的元素
print('------读取下标对应的元素------')
x2 = x[[0, 6]]
print(x2)

print(x2[0])
print(x2[1])

## 二位数组
# 传入顺序索引数组
x = np.arange(32).reshape((8, 4))
print(x)
# 二维数组读取指定下标对应的行
print('------读取下标对应的行------')
print(x[[4, 2, 1, 7]])

print()

# 传入倒序索引组
x = np.arange(32).reshape((8, 4))
print(x[[-4, -2, -1, -7]])

print()

# 传入多个索引数组（要使用 np.ix_）
# np.ix_() 函数就是输入两个数组, 产生笛卡尔积的映射关系
# 笛卡尔积是指在数学中, 两个集合 X 和 Y 的笛卡尔积（Cartesian product）, 又称直积, 表示为 X * Y,
# 第一个对象是 X 的成员而第二个对象是 Y 的所有可能序对的其中一个成员
x = np.arange(32).reshape((8, 4))
print(x[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])])

